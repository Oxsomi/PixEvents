// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#include "pch.h"

#include <d3d12.h> // yes, this must be included before pix3.h
#include <pix3.h>

#include <PixEventDecoder.h>

// This file loads blocks generated by an old (2022) copy of WinPixEventRuntime, passes them through the decoder, and validates the output.
// The tests are heavily based on the unit tests in TestWinPixEventRuntime.cpp as/of 12/29/2022.

class DecodeTimingBlock_LegacyBlockFormat : public ::testing::Test
{
    struct Expected
    {
        PixEventType Type;
        uint32_t Color;
        std::wstring Name;
        uint64_t Context;
    };
    
    std::vector<Expected> m_expected;

public:
    void Expect(PixEventType type, uint32_t color, std::wstring name, void* context = nullptr)
    {
        m_expected.push_back({ type, color, std::move(name), reinterpret_cast<uint64_t>(context) });
    }

    void Validate(std::vector<byte>& block)
    {
        auto data = PixEventDecoder::DecodeTimingBlock(true, block.size(), block.data(), [](uint64_t time) { return time; });

        ASSERT_EQ(m_expected.size(), data.Events.size());
        ASSERT_EQ(m_expected.size(), data.D3D12Contexts.size());

        for (auto i = 0u; i < m_expected.size(); ++i)
        {
            auto const& expected = m_expected[i];
            auto const& actual = data.Events[i];
            auto const& actualContext = data.D3D12Contexts[i];

            ASSERT_EQ((int)expected.Type, (int)actual.Type);
            ASSERT_EQ(expected.Color, actual.Color);
            ASSERT_EQ(expected.Name, actual.Name);
            ASSERT_EQ(expected.Context, actualContext);
        }
    }
};

TEST_F(DecodeTimingBlock_LegacyBlockFormat, BeginEvent)
{
    std::ifstream input("WinPixEventRuntimeData\\LegacyBlockFormatData\\BeginEvent.dat", std::ios::binary);
    ASSERT_FALSE(input.fail()) << L"Failed to open file";

    // The block was created from the following events:
    //
    //    PIXBeginEvent(1, "hello");
    //    PIXBeginEvent(2, L"hello");
    //    PIXBeginEvent(3, "hello %s %d %f", "world", 1, 1.0f);
    //    PIXBeginEvent(4, L"hello %s %d %f", L"world", 2, 2.0f);
    //    PIXBeginEvent(context, 5, "hello");
    //    PIXBeginEvent(context, 6, L"hello");
    //    PIXBeginEvent(context, 7, "hello %s %d %f", "world", 3, 3.0f);
    //    PIXBeginEvent(context, 8, L"hello %s %d %f", L"world", 4, 4.0f);

    void* expectedContext = (void*)19537063328; // This is hardcoded into the block

    std::vector<uint8_t> block(std::istreambuf_iterator<char>(input), {});

    Expect(PixEventType::Begin, 1, L"hello");
    Expect(PixEventType::Begin, 2, L"hello");
    Expect(PixEventType::Begin, 3, L"hello world 1 1.000000");
    Expect(PixEventType::Begin, 4, L"hello world 2 2.000000");
    Expect(PixEventType::Begin, 5, L"hello", expectedContext);
    Expect(PixEventType::Begin, 6, L"hello", expectedContext);
    Expect(PixEventType::Begin, 7, L"hello world 3 3.000000", expectedContext);
    Expect(PixEventType::Begin, 8, L"hello world 4 4.000000", expectedContext);

    Validate(block);
}

TEST_F(DecodeTimingBlock_LegacyBlockFormat, SetMarker)
{
    std::ifstream input("WinPixEventRuntimeData\\LegacyBlockFormatData\\SetMarker.dat", std::ios::binary);
    ASSERT_FALSE(input.fail()) << L"Failed to open file";

    // The block was created from the following events:
    //
    //    PIXSetMarker(1, "hello");
    //    PIXSetMarker(2, L"hello");
    //    PIXSetMarker(3, "hello %s %d %f", "world", 1, 1.0f);
    //    PIXSetMarker(4, L"hello %s %d %f", L"world", 2, 2.0f);
    //    PIXSetMarker(expectedContext, 5, "hello");
    //    PIXSetMarker(expectedContext, 6, L"hello");
    //    PIXSetMarker(expectedContext, 7, "hello %s %d %f", "world", 3, 3.0f);
    //    PIXSetMarker(expectedContext, 8, L"hello %s %d %f", L"world", 4, 4.0f);

    void* expectedContext = (void*)936854416720; // This is hardcoded into the block

    std::vector<uint8_t> block(std::istreambuf_iterator<char>(input), {});

    Expect(PixEventType::Marker, 1, L"hello");
    Expect(PixEventType::Marker, 2, L"hello");
    Expect(PixEventType::Marker, 3, L"hello world 1 1.000000");
    Expect(PixEventType::Marker, 4, L"hello world 2 2.000000");
    Expect(PixEventType::Marker, 5, L"hello", expectedContext);
    Expect(PixEventType::Marker, 6, L"hello", expectedContext);
    Expect(PixEventType::Marker, 7, L"hello world 3 3.000000", expectedContext);
    Expect(PixEventType::Marker, 8, L"hello world 4 4.000000", expectedContext);

    Validate(block);
}

TEST_F(DecodeTimingBlock_LegacyBlockFormat, EndEvent)
{
    std::ifstream input("WinPixEventRuntimeData\\LegacyBlockFormatData\\EndEvent.dat", std::ios::binary);
    ASSERT_FALSE(input.fail()) << L"Failed to open file";

    // The block was created from the following events:
    //
    //    PIXEndEvent();
    //    PIXEndEvent(expectedContext);

    void* expectedContext = (void*)1098351899584; // This is hardcoded into the block

    std::vector<uint8_t> block(std::istreambuf_iterator<char>(input), {});

    Expect(PixEventType::End, 0, L"");
    Expect(PixEventType::End, 0, L"", expectedContext);

    Validate(block);
}

TEST_F(DecodeTimingBlock_LegacyBlockFormat, TruncatedEventNames)
{
    std::ifstream input("WinPixEventRuntimeData\\LegacyBlockFormatData\\TruncatedEventNames.dat", std::ios::binary);
    ASSERT_FALSE(input.fail()) << L"Failed to open file";

    // The block was created from the following events:
    //
    //     std::string s;
    //     for (int i = 0; i < 1024; ++i)
    //         s.push_back('A' + (i % 64));
    // 
    //     for (uint32_t = count; count < 9; count++)
    //     {
    //         PIXBeginEvent(count, s.c_str() + (count % s.size()));
    //         PIXEndEvent();
    //         PIXSetMarker(count, s.c_str() + (count % s.size()));
    //         ++count;
    //     }

    std::vector<uint8_t> block(std::istreambuf_iterator<char>(input), {});

    uint32_t expectedNext = 0;

    auto data = PixEventDecoder::DecodeTimingBlock(true, block.size(), block.data(), [] (uint64_t time) { return time; });
    for (auto const& event : data.Events)
    {
        PixEventType expectedEvent;
        switch (expectedNext % 3)
        {
            case 0: expectedEvent = PixEventType::Begin; break;
            case 1: expectedEvent = PixEventType::End; break;
            case 2: expectedEvent = PixEventType::Marker; break;
            default:
                GTEST_FAIL();
        }
    
        ASSERT_EQ((int)expectedEvent, (int)event.Type);
    
        if (event.Type != PixEventType::End)
            ASSERT_EQ(expectedNext / 3, event.Color);
    
        expectedNext++;
    }

    ASSERT_EQ(9u - 1u, expectedNext / 3);
}

TEST_F(DecodeTimingBlock_LegacyBlockFormat, TruncatedFormattedStrings)
{
    std::ifstream input("WinPixEventRuntimeData\\LegacyBlockFormatData\\TruncatedFormattedStrings.dat", std::ios::binary);
    ASSERT_FALSE(input.fail()) << L"Failed to open file";

    // The block was created from the following events:
    //
    //     std::string s;
    //     for (int i = 0; i < 2048; ++i)
    //         s.push_back('A');
    // 
    //     for (uint32_t count = 0u; count < 5; count++)
    //     {
    //         PIXBeginEvent(count, "%s", s.c_str() + (count % s.size()));
    //         PIXEndEvent();
    //         PIXSetMarker(count, "%s", s.c_str() + (count % s.size()));
    //         ++count;
    //     }

    std::vector<uint8_t> block(std::istreambuf_iterator<char>(input), {});

    std::string s;
    for (int i = 0; i < 2048; ++i)
        s.push_back('A');

    uint32_t expectedNext = 0;
    bool sawTruncated = false;

    auto data = PixEventDecoder::DecodeTimingBlock(true, block.size(), block.data(), [](uint64_t time) { return time; });
    for (auto const& event : data.Events)
    {
        PixEventType expectedEvent;
        switch (expectedNext % 3)
        {
            case 0: expectedEvent = PixEventType::Begin; break;
            case 1: expectedEvent = PixEventType::End; break;
            case 2: expectedEvent = PixEventType::Marker; break;
            default:
                GTEST_FAIL();
        }
    
        ASSERT_EQ((int)expectedEvent, (int)event.Type);
    
        if (event.Type != PixEventType::End)
        {
            ASSERT_EQ(expectedNext / 3, event.Color);
    
            // It's not great that we truncate the strings at all.
            // However, if we do we shouldn't see any garbage in it.
            auto* p = event.Name;
            while (*p)
            {
                ASSERT_EQ(L'A', *p);
                ++p;
            }
    
            if (s.size() - (event.Color % s.size()) != wcslen(event.Name))
                sawTruncated = true;
        }
    
        expectedNext++;
    }

    ASSERT_TRUE(sawTruncated) << L"Didn't see a truncated string";
    ASSERT_EQ(5u - 1u, expectedNext / 3);
}

//
// The old pix event buffer format doesn't actually contain an argument
// count - instead it relies on being able to guess where the next event
// is so that it can skip the argument buffers. This case confuses this logic.
//
TEST_F(DecodeTimingBlock_LegacyBlockFormat, MismatchedFormatStrings)
{
    std::ifstream input("WinPixEventRuntimeData\\LegacyBlockFormatData\\MismatchedFormatStrings.dat", std::ios::binary);
    ASSERT_FALSE(input.fail()) << L"Failed to open file";

    // The block was created from the following events:
    //
    //  for (int i = 0; i < 10; ++i)
    //  {
    //      PIXSetMarker(i, "GCMARKING", (uint64_t)0xFFFFFFFFFFF00000);
    //  }

    std::vector<uint8_t> block(std::istreambuf_iterator<char>(input), {});

    for (int i = 0; i < 10; ++i)
    {
        Expect(PixEventType::Marker, i, L"GCMARKING");
    }

    Validate(block);
}
